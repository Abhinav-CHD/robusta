import json
import logging
from typing import List, Optional
from threading import Lock

import kubernetes
from hikaru.model import ObjectMeta

from ...core.schedule.model import ScheduledJob
from ...integrations.kubernetes.autogenerated.v1.models import ConfigMap

JOBS_CONFIGMAP_NAME = "scheduled-jobs"
CONFIGMAP_NAMESPACE = "robusta"


class SchedulerDal:
    mutex = Lock()

    def __init__(self):
        self.__init_scheduler_dal()

    @classmethod
    def __load_config_map(cls) -> ConfigMap:
        return ConfigMap.readNamespacedConfigMap(
            JOBS_CONFIGMAP_NAME, CONFIGMAP_NAMESPACE
        ).obj

    @classmethod
    def __init_scheduler_dal(cls):
        try:
            cls.__load_config_map()
        except kubernetes.client.exceptions.ApiException as e:
            # we only want to catch exceptions because the config map doesn't exist
            if e.reason != "Not Found":
                raise
            # job states configmap doesn't exists, create it
            cls.mutex.acquire()
            try:
                conf_map = ConfigMap(
                    metadata=ObjectMeta(
                        name=JOBS_CONFIGMAP_NAME, namespace=CONFIGMAP_NAMESPACE
                    )
                )
                conf_map.createNamespacedConfigMap(conf_map.metadata.namespace)
                logging.info(
                    f"created jobs states configmap {JOBS_CONFIGMAP_NAME} {CONFIGMAP_NAMESPACE}"
                )
            finally:
                cls.mutex.release()

    @classmethod
    def save_scheduled_job(cls, job: ScheduledJob):
        cls.mutex.acquire()
        try:
            confMap = cls.__load_config_map()
            confMap.data[job.job_id] = job.json()
            confMap.replaceNamespacedConfigMap(
                confMap.metadata.name, confMap.metadata.namespace
            )
        finally:
            cls.mutex.release()

    @classmethod
    def get_scheduled_job(cls, job_id: str) -> Optional[ScheduledJob]:
        state_data = cls.__load_config_map().data.get(job_id)
        return (
            ScheduledJob(**json.loads(state_data)) if state_data is not None else None
        )

    @classmethod
    def del_scheduled_job(cls, job_id: str):
        cls.mutex.acquire()
        try:
            confMap = cls.__load_config_map()
            if confMap.data.get(job_id) is not None:
                del confMap.data[job_id]
                confMap.replaceNamespacedConfigMap(
                    confMap.metadata.name, confMap.metadata.namespace
                )
        finally:
            cls.mutex.release()

    @classmethod
    def list_scheduled_jobs(cls) -> List[ScheduledJob]:
        return [
            cls.get_scheduled_job(job_id)
            for job_id in cls.__load_config_map().data.keys()
        ]
